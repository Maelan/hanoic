/**
***  io.c
***
***    module:   io  −  source file
***    function: The interaction module (thread), which listen what the user do
***              and draw beautiful things onto the screen.
***    author:   Maëlan (aka Maëlan44)
***              (see < http://www.siteduzero.com/membres-294-232877.html >)
***
**/

#include "io.h"





static WINDOW*  nWin = NULL;
static WINDOW*  mWin = NULL;
static WINDOW*  statsWin = NULL;
static WINDOW*  playWin = NULL;



static GraphicPosition  gpos = {
	.h = { 0, 0, 0 }
};



static Selection  sel = {
	.n = 0,
	.cur = 1
};



static char const* digits[10] = {
	" ###  \n"
	"## ## \n"
	"## ## \n"
	"## ## \n"
	"## ## \n"
	"## ## \n"
	" ###  \n",
	
	"  ##   \n"
	"####   \n"
	"  ##   \n"
	"  ##   \n"
	"  ##   \n"
	"  ##   \n"
	"###### \n",
	
	" ###  \n"
	"## ## \n"
	"   ## \n"
	"  ##  \n"
	" ##   \n"
	"## ## \n"
	"##### \n",
	
	" ###  \n"
	"## ## \n"
	"   ## \n"
	" ###  \n"
	"   ## \n"
	"## ## \n"
	" ###  \n",
	
	"   ##  \n"
	"  ###  \n"
	" # ##  \n"
	"## ##  \n"
	"###### \n"
	"   ##  \n"
	"   ##  \n",
	
	"##### \n"
	"##    \n"
	"####  \n"
	"## ## \n"
	"   ## \n"
	"#  ## \n"
	"####  \n",
	
	" ###  \n"
	"## ## \n"
	"##    \n"
	"####  \n"
	"## ## \n"
	"## ## \n"
	" ###  \n",
	
	"##### \n"
	"## ## \n"
	"   ## \n"
	"  ##  \n"
	"  ##  \n"
	" ##   \n"
	" ##   \n",
	
	" ###  \n"
	"## ## \n"
	"## ## \n"
	" ###  \n"
	"## ## \n"
	"## ## \n"
	" ###  \n",
	
	" ###  \n"
	"## ## \n"
	"## ## \n"
	" #### \n"
	"   ## \n"
	"## ## \n"
	" ###  \n"
	
	/*
	 ###    ##    ###   ###     ##  #####  ###  #####  ###   ###  
	## ## ####   ## ## ## ##   ###  ##    ## ## ## ## ## ## ## ## 
	## ##   ##      ##    ##  # ##  ####  ##       ## ## ## ## ## 
	## ##   ##     ##   ###  ## ##  ## ## ####    ##   ###   #### 
	## ##   ##    ##      ## ######    ## ## ##   ##  ## ##    ## 
	## ##   ##   ## ## ## ##    ##  #  ## ## ##  ##   ## ## ## ## 
	 ###  ###### #####  ###     ##  ####   ###   ##    ###   ###  
	*/
};



static void   initNWin
	(void)
{
	//nWin = newwin(NWIN_H, NWIN_W, NWIN_Y, NWIN_X);
	nWin = newwin(7,8, 0,0);
	mWin = newwin(7,8, 0,7);
	
	wattron(nWin, COLOR_PAIR(20));
	wrefresh(nWin);
	wattron(mWin, COLOR_PAIR(20));
	wrefresh(mWin);
}



static void  printN
  (unsigned n)
{
	unsigned m = UINT_MAX;
	
	if(n >= 10) {
		m = n%10;
		n /= 10;
	}
	
	wclear(nWin);
	wclear(mWin);
	
	waddstr(nWin, digits[n]);
	if(m != UINT_MAX)
		//mvwaddstr(nWin, 0, 7, digits[m]);
		waddstr(mWin, digits[m]);
	
	wrefresh(nWin);
	wrefresh(mWin);
}



static void   initStatsWin
	(void)
{
	statsWin = newwin(STATSWIN_H, STATSWIN_W, STATSWIN_Y, STATSWIN_X);
	
	waddstr(statsWin,
	  "   you      |      optimal solution\n"
	  "errors      |      from now" );
	
	/* Emphasis over “you” and “optimal”. */
	mvwchgat(statsWin, 0,  3,  3, A_BOLD, 0, NULL);    /* “you” */
	mvwchgat(statsWin, 0, 19,  7, A_BOLD, 0, NULL);    /* “optimal” */
}



static void  updateStats
  (Statistics const* stats)
{
	mvwprintw(statsWin, 0,  7,  "% 4u", stats->done);       /* you */
	mvwprintw(statsWin, 1,  7,  "% 4u", stats->errors);     /* errors */
	mvwprintw(statsWin, 0, 14,  "%-4u", stats->initial);    /* optimal */
	mvwprintw(statsWin, 1, 14,  "%-4u", stats->fromNow);    /* from now */
	
	/* Color over these numbers. :) */
	mvwchgat(statsWin, 0,  7,  4, A_BOLD, 10, NULL);    /* you */
	mvwchgat(statsWin, 1,  7,  4, A_BOLD, 11, NULL);    /* errors */
	mvwchgat(statsWin, 0, 14,  4, A_BOLD, 12, NULL);    /* optimal */
	mvwchgat(statsWin, 1, 14,  4, A_BOLD, 13, NULL);    /* from now */
	
	wrefresh(statsWin);
}



static void  initPlayWin
  (void)
{
	playWin = newwin(PLAYWIN_H, PLAYWIN_W, PLAYWIN_Y, PLAYWIN_X);
	keypad(playWin, true);
	nodelay(playWin, true);
	
	wattron(playWin, COLOR_PAIR(20));
}



static void  drawDisk
  (unsigned n, unsigned peg, unsigned h, bool draw)
{
	wmove(playWin, PLAYWIN_H-1-h, (2*MAX_N+1+GAP_X)*(peg-1)+MAX_N+n-(n>9));
	if(draw)
		wprintw(playWin, "%u", n);
	else
		wprintw(playWin, "  ");
	mvwchgat(playWin, PLAYWIN_H-1-h, (2*MAX_N+1+GAP_X)*(peg-1)+MAX_N-n,
	  2*n+1, (draw ? A_BOLD : A_NORMAL), (draw ? n%8+1 : 20), NULL);
	wrefresh(playWin);
}



static void  teleportDisk
  (unsigned n, unsigned src, unsigned hSrc, unsigned dest, unsigned hDest)
{
	drawDisk(n, src, hSrc, false);
	drawDisk(n, dest, hDest, true);
}



static void  moveDisk
  (Move const* mv)
{
	unsigned n = gpos.pegs[mv->src-1][gpos.h[mv->src-1]-1];
	gpos.h[mv->src-1]--;
	gpos.h[mv->dest-1]++;
	gpos.pegs[mv->dest-1][gpos.h[mv->dest-1]-1] = n;
	
	teleportDisk( n,
	  mv->src, gpos.h[mv->src-1]+1,
	  mv->dest, gpos.h[mv->dest-1] );
}



static void  moveCursor
  (unsigned newCur)
{
	mvwhline(playWin, PLAYWIN_H-1, (2*MAX_N+1+GAP_X)*(sel.cur-1), ' ', 2*MAX_N+1);
	mvwhline(playWin, PLAYWIN_H-1, (2*MAX_N+1+GAP_X)*(newCur-1), ':', 2*MAX_N+1);
	wrefresh(playWin);
	
	sel.cur = newCur;
}



static void  select
  (void)
{
	if(!gpos.h[sel.cur-1])
		return;
	
	sel.orig = sel.cur;
	sel.n = gpos.pegs[sel.cur-1][gpos.h[sel.cur-1]-1];
	gpos.h[sel.cur-1]--;
	
	teleportDisk(sel.n, sel.cur, gpos.h[sel.cur-1]+1, sel.cur, MAX_N+GAP_Y);
}



static void  release
  (void)
{
	if(gpos.h[sel.cur-1]  &&  sel.n > gpos.pegs[sel.cur-1][gpos.h[sel.cur-1]-1])
		return;
	
	teleportDisk(sel.n, sel.orig, MAX_N+GAP_Y, sel.cur, gpos.h[sel.cur-1]+1);
	
	if(sel.cur != sel.orig) {
		Signal sig = {
			.type = SIG_NEWMOVE,
			.mv = { .src = sel.orig, .dest = sel.cur }
		};
		sendSignal(&brain, &sig);
	}
	
	gpos.pegs[sel.cur-1][gpos.h[sel.cur-1]] = sel.n;
	gpos.h[sel.cur-1]++;
	sel.n = 0;
}



static void  toggleSelected
  (void)
{
	if(sel.n)
		release();
	else
		select();
}



static void  attemptMove
  (unsigned peg1, unsigned peg2)
{
	Signal sig;
	Move mv;
	unsigned n1 = (gpos.h[peg1-1]) ? gpos.pegs[peg1-1][gpos.h[peg1-1]-1] : MAX_N+1,
	         n2 = (gpos.h[peg2-1]) ? gpos.pegs[peg2-1][gpos.h[peg2-1]-1] : MAX_N+1;
	
	if(n1 == n2)          /* nothing (both pegs are empty) */
		return;
	else if(n1 < n2) {    /* peg1 → peg2 */
		//mv.n = n1;
		mv.src = peg1;
		mv.dest = peg2;
	}
	else {                /* peg1 ← peg2 */
		//mv.n = n2;
		mv.src = peg2;
		mv.dest = peg1;
	}
	
	sig.type = SIG_NEWMOVE;
	sig.mv = mv;
	sendSignal(&brain, &sig);
	
	moveDisk(&mv);
}



static void  updatePosition
  (Position const* pos)
{
	/* Update the position datas. */
	gpos.h[0] = 0;
	gpos.h[1] = 0;
	gpos.h[2] = 0;
	for(unsigned i = 0;  i < pos->n;  i++)
		gpos.pegs[pos->pos[i]-1][gpos.h[pos->pos[i]-1]++] = pos->n-i;    /* RoOooOoock! */
	
	printN(pos->n);
	
	wclear(playWin);
	overlay(nWin, playWin);
	overlay(mWin, playWin);
	
	/* Draw the 3 pegs. */
	for(unsigned i = 0;  i < 3;  i++)
		mvwvline(playWin, GAP_Y, (2*MAX_N+1+GAP_X)*i + MAX_N, '|', MAX_N);
	/* Draw the disks. */
	for(unsigned i = 0;  i < 3;  i++)
		for(unsigned j = 0;  j < gpos.h[i];  j++)
			drawDisk(gpos.pegs[i][j], i+1, j+1, true);
	/*  Show the “cursor”.*/
	moveCursor(1);
	
	wrefresh(playWin);
}



void*  ioProc
  (void* self)
{
	Signal* sig;
	Signal send;
	bool again;
	int c;
	
	initscr();
	/* Input settings. */
	cbreak();
	//keypad(stdscr, true);
	//mousemask(BUTTON1_CLICKED, NULL);
	noecho();
	curs_set(0);
	/* Output settings. */
	start_color();
	use_default_colors();
	for(int i = 0;  i < 8; ++i)    /* 8 color pairs for the disks */
		init_pair(i+1, i, i);
	init_pair(10, COLOR_YELLOW, -1);    /* color pairs for statistics */
	init_pair(11, COLOR_RED,    -1);    /* … */
	init_pair(12, COLOR_GREEN,  -1);    /* … */
	init_pair(13, COLOR_BLUE,   -1);    /* … */
	init_pair(20, COLOR_BLACK,   -1);    /* color for drawig (bigN and pegs) */
	refresh();
	
	/* Windows. */
	initNWin();
	initStatsWin();
	initPlayWin();
	
	again = true;
	while(again) {
		sig = getSignal(self);
		
		if(sig) {
			switch(sig->type) {
			  case SIG_NEWPOS:
				sendSignal(&brain, sig);
				updatePosition(&sig->pos);
				break;
			  case SIG_NEWMOVE:
				sendSignal(&brain, sig);
				moveDisk(&sig->mv);
				break;
			  case SIG_STATSUPDATE:
				updateStats(&sig->stats);
				break;
			  default:
				break;
			}
			
			destroySignal(sig);
		}
		
		c = wgetch(playWin);
		switch(c) {
		  /* Quit. */
		  case 'q':
			send.type = SIG_END;
			sendSignal(&brain, &send);
			again = false;
			break;
		  /* Move the “cursor” (under the pegs). */
		  case KEY_LEFT:
			moveCursor((sel.cur==1) ? 3 : sel.cur-1);
			break;
		  case KEY_RIGHT:
			moveCursor(sel.cur%3 + 1);
			break;
		  case '1':
		  case '2':
		  case '3':
			moveCursor(c-'0');
			break;
		  /* Select/release a disk. */
		  case ' ':
			toggleSelected();
			break;
		  /* Shortcuts to move the cursor and select a disk. */
		  case '4':
		  case '5':
		  case '6':
			moveCursor(c-'3');
			toggleSelected();
			break;
		  /* Even shorter shortcuts to play a move directly. */
		  case '7':
			attemptMove(1,2);    break;
		  case '8':
			attemptMove(1,3);    break;
		  case '9':
			attemptMove(2,3);    break;
		  /* Play the next move of the solution. */
		  case 's':
			send.type = SIG_NEXTMOVE;
			sendSignal(&brain, &send);
			break;
		  case ERR:
		  default:
			break;
		}
	}
	
	delwin(nWin);
	delwin(statsWin);
	delwin(playWin);
	endwin();
	
	pthread_exit(NULL);
}
